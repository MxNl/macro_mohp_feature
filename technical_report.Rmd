---
title: "EU-MOHP v013.1.1"
subtitle: "Technical Report of the Source Code"
author:
  - name: Maximilian Noelscher
abstract: |
  The presented dataset EU-MOHP v013.1.1 provides cross-scale information on the hydrologic position (MOHP) of a geographic point within its respective river network and catchment as gridded maps. More precisely, it comprises the three measures “lateral position” (LP) as a relative measure of the position between the stream and the catchment divide, “divide stream distance” (DSD) as sum of the distances to the nearest stream and divide and “stream distance” (SD) as an absolute measure of the distance to the nearest stream. These three measures are calculated for several hydrologic orders to reflect different spatial scales. Its spatial extent covers major parts of the European Economic Area (EEA39) which also largely coincides with physiographical Europe. Although there are multiple potential use cases, this dataset serves predominantly as valuable static environmental feature or predictor variable for hydrogeological and hydrological modelling such as mapping or forecasting tasks using machine learning. The generation of this dataset uses free open source software only and therefore can be applied to different spatial regions or input datasets.
output: 
  pdf_document:
    extra_dependencies: ["float", "tabu", "threeparttable", "threeparttablex", "amsmath", "longtable", "multirow", "booktabs"]
bibliography: eu-mohp.bib
nocite: '@*'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center', fig.pos = "H", message = FALSE, warning = FALSE, fig.showtext = TRUE, size = "small", attr.output = ".numberLines", fig.path = "data_descriptor/tex/techrep-figure-", eval.after = "fig.cap")
options(tinytex.verbose = TRUE)

# Remove white space from pdf figures
knitr::knit_hooks$set(crop = knitr::hook_pdfcrop)

# knitr hook for code chunk font size
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

library(knitr)
library(showtext)


library(targets)
source("R/constants.R")
library(assertr)
library(bibtex)
library(citr)
library(clipr)
library(data.table)
library(DBI)
library(dtplyr)
library(fs)
library(furrr)
library(ggridges)
library(glue)
library(here)
library(hues)
library(igraph)
library(janitor)
library(knitr)
library(lwgeom)
library(magick)
library(patchwork)
library(pdftools)
library(raster)
library(RefManageR)
library(renv)
library(rgdal)
library(rgeos)
library(rgrass7)
library(rmapshaper)
library(rmarkdown)
library(rnaturalearth)
library(rnaturalearthdata)
library(RPostgres)
library(sf)
library(sfheaders)
library(showtext)
library(stars)
library(styler)
library(tarchetypes)
library(tidyverse)
library(tmap)
source("R/import_functions.R")
source("R/preprocessing_functions.R")
source("R/database_functions.R")
source("R/postgis_functions.R")
source("R/grass_functions.R")
source("R/export_functions.R")

source("data_descriptor/targets/R/visualization_functions.R")
source("data_descriptor/targets/R/eumohpclipr_functions.R")
source("data_descriptor/targets/R/helper_functions.R")
source("data_descriptor/targets/R/constants.R")


# Add font for ggplots
font_add("Corbel", regular = "C:\\Windows\\Fonts\\corbel.ttf")
```

# Introduction {-}

All processing and calculation steps are either done in or controlled and tracked through the R programming language (Figure \@ref(fig:workflowfigure)C) [@r_core_team_r_2020]. Due to the memory size of this dataset as well as for the sake of computational speed, a PostgreSQL database with PostGIS extension is used for some processing steps of vector data and a GRASS GIS database is used for all final raster based calculations of the EU-MOHP[@nolscher_eu-mohp_2021-1] metrics (Figure \@ref(fig:workflowfigure)D and E). For reproducibility and programming reasons, all processing steps including the databases are tracked and executed through a data processing pipeline using the targets package in R (Figure \@ref(fig:workflowfigure)C) [@landau_targets_2021]. More details can be found in the technichal report or the source code itself (see [Code availability]). This processing or targets pipeline can be seen as programming script that tracks each step and skips processing steps that are still up-to-date when re-running the script after changes in the code.

To better refer to the code during the description of the methods, each processing step provides the name of its related target in the targets pipeline and the file containing this target. Targets titled as *helper target* in the code are not described here because they are not relevant to the description of the methods and exist only for technical reasons. For consistency, all column names are changed to lowercase, e.g. *OBJECT_ID* to *object_id*. The usage of "processing step" translates to a "target" in the targets pipeline which is also called "processing pipeline".

\begin{equation}
\text{LP}_i = \frac{\text{DS}_i}{\text{DS}_i + \text{DD}_i} (\#eq:eqlp)
\end{equation}

\begin{equation}
\text{DSD}_i = \text{DS}_i + \text{DD}_i (\#eq:eqdsd)
\end{equation}

\begin{equation}
\text{SD}_i = \text{DS}_i (\#eq:eqsd)
\end{equation}

# Directory \& File Structure {-}

The directory and file structure of the project folder containing all code and files to generate this dataset is summarized in Figure \@ref(fig:projectdirtree) in a tree structure. Files and directories that are not relevant for describing the methods are not shown here. The project folder as the top level directory is the working directory. The file *config.yml* (line `r dirtree_lineno("config.yml")`) contains definitions of variables that are meant to be set by a user before running the targets pipeline. The most relevant variable is *cellsize* which sets the spatial resolution of the resulting EU-MOHP gridded maps[@nolscher_eu-mohp_2021-1]. Another important variable is *area* to switch between a test study area and the complete study area for all EEA39. The test study area represents a small fraction of the study area. This reduces the runtime of the pipeline for testing purposes. The folder *grassdata* (line `r dirtree_lineno("grassdata")`) is used for writing the GRASS GIS databases to. The folder *input_data* (line `r dirtree_lineno("input_data")`) contains all required input data. Firstly, the sub-folder *data* (line `r dirtree_lineno("data")`) comprises the river network data as one single folder per basin as it is derived after unzipping the downloaded “EU-Hydro -- River Network Database” data[@noauthor_eu-hydro_2021] (see [Underlying Dataset]). The second sub-folder *EUHYDRO_Coastline_EEA39_v013* (line `r dirtree_lineno("EUHYDRO_Coastline_EEA39_v013")`) contains the coastline data (see [Underlying Dataset]). The third sub-folder *studyarea_test* (line `r dirtree_lineno("studyarea_test")`) contains a test study area as Shape file for pipeline testing purposes only (see [Code availability]). The file *macro_mohp_feature.Rproj* (line `r dirtree_lineno("macro_mohp_feature.Rproj")`) is the R project file. The folder *output_data* (line `r dirtree_lineno("output_data")`) contains three sub-directories where the final EU-MOHP gridded maps[@nolscher_eu-mohp_2021-1] are written to. These directories are created by the pipeline if they don't already exist. *R* (line `r dirtree_lineno("R")`) contains R scripts where custom functions and constants are defined. *renv* (line `r dirtree_lineno("renv")`) and the file *renv.lock* (line `r dirtree_lineno("renv.lock")`) are related to the R package renv that tracks versions of package dependencies [@ushey_renv_2021]. The R script *run_pipeline.R* (line `r dirtree_lineno("run_pipeline.R")`) contains code to execute the targets pipeline that does all the data processing and calculations. *targets* (line `r dirtree_lineno("targets")`) contains the definition of all targets or processing steps of the pipeline. For overview reasons, it is split thematically across multiple files. *\_targets* (line `r dirtree_lineno("_targets")`) is used by the targets package internally. The file *\_targets.R* (line `r dirtree_lineno("_targets.R")`) sets up the targets pipeline and loads all dependencies.

# Underlying Dataset {-}

The generation of this dataset is based on two data products, the “EU-Hydro -- River Network Database” version v013[@noauthor_eu-hydro_2021] and “EU-Hydro -- Coastline” version v013[@noauthor_eu-hydro_2021-1] with the advantage that data dependencies are low. Therefore, it is possible to transfer the methodology to other regions with only little effort. Table \@ref(tab:inputdata) provides an overview of the input data layers necessary for generating the dataset. These input data layers are all derived from layers of GeoPackages or Shape files of the two previously mentioned data products.

The “EU-Hydro -- River Network Database”[@noauthor_eu-hydro_2021] as well as the “EU-Hydro -- Coastline”[@noauthor_eu-hydro_2021-1] has been manually downloaded from the Copernicus - Land Monitoring Service website (Figure \@ref(fig:workflowfigure)A) in GeoPackage (*.gpkg*) and Shapefile (*.shp*) file format, respectively (Figure \@ref(fig:workflowfigure)B) [@noauthor_eu-hydro_2021; noauthor_eu-hydro_2021-1]. The river network data is provided as two .gpkg files in one folder with the suffix *\_GPKG* in the folder name for each of the `r targets::tar_read(river_networks_files) %>% length()` major river basins in the EEA39 countries. All files have a total size of approximately 14GB when unzipped. The single *.shp* file containing the coastline has a size of 288MB. For instructions on accessing this underlying data, see [Code availability].

# Data Import {-}

The river network comprises the layers `r STREAM_TYPE_TO_INCLUDE %>% collapse_text_italic()` in the "*euhydro_\<name of the river basin\>\_v013*" named .gpkg file of all river basins of the river network data. They are imported with the target *river_networks* in *import_targets.R* (Figure \@ref(fig:projectdirtree), line `r dirtree_lineno("import_targets.R")`) from the directory *input_data/data*. The layer *Canals_l* contains canals, which are defined as "an artificial waterway with no flow, or a controlled flow, usable or built for navigation" [@gallaun_eu-hydro_2019]. The layer *Ditches_l* contains ditches, which are defined as "an artificial waterway with no flow, or a controlled flow, usually unlined, used for draining or irrigating land" [@gallaun_eu-hydro_2019]. The layer *Rivers_l* contains rivers, which are defined as "a naturally flowing watercourse" [@gallaun_eu-hydro_2019]. 

The surface water bodies are derived from the layer *InlandWater*. This layer is imported by the target *inland_waters* in *import_targets.R* and contains inland water defined as "a large body of water entirely surrounded by land." [@gallaun_eu-hydro_2019]. In the same step, all geometries with an area smaller than $4 \cdot \text{cellsize}^2 = 4 \cdot (`r CELLSIZE`\: \text{m})^2  = `r CELLSIZE^2 * 4`\: \text{m}^2$, where cellsize is the spatial resolution, are removed to exclude geometries that only have a negligible impact on the result.

The river basins are based on the layer "*\<name of river basin\>\_eudem2_basins_h1*" in the "*drainage_network_\<name of the river basin\>\_public_beta_v009*" named .gpkg file. This layer is imported with the target *river_basins* in *studyarea_targets.R* (Figure \@ref(fig:projectdirtree), line `r dirtree_lineno("studyarea_targets.R")`) and contains polygon geometries of all sub-basins of each major basin. The spatial coverage of the river basins is the basis for the study area. The study area itself delineates the area for which the EU-MOHP[@nolscher_eu-mohp_2021-1] metrics will be calculated.

The fourth required input data layer is the coastline. It is imported with the target *coastline_grouped* in *studyarea_targets.R*.

In this study, the coordinate reference system (CRS) ETRS89-extended / LAEA Europe with the EPSG code `r CRS_REFERENCE` is used. Therefore, all data is reprojected to this CRS after importing if necessary.

# Preprocessing {-}

## River Basins/ Study Area {-}

The preprocessing steps related to the river basins are described first because they aim at the determination of a study area, which is required for subsequent processing steps. The EU-MOHP[@nolscher_eu-mohp_2021-1] measures are then calculated for this area as a last step. The following steps refer to targets that can be found in the file *studyarea_targets.R* (Figure \@ref(fig:projectdirtree), `r dirtree_lineno("studyarea_targets.R")`). After the previously mentioned import, the sub-basins are unioned basin-wise (target: *river_basins_unioned*). Then, all polygons belonging to European oversea territories such as the French islands in the Caribbean are removed (target: *river_basins_subset*). The resulting polygon geometries are unioned in the PostgreSQL database (target: *river_basins_subset_union_in_db*) to reduce the runtime of this union. Previous attempts to perform this union in R have shown too long runtimes, because the polygon geometries have a large amount of nodes due to the high details in the digitized coastline. Subsequently, out of these polygons of contiguous land masses the 10 largest polygons by area are chosen as study area (target: *river_basins_region_name*). Lastly, names are automatically assigned to each of the polygons (target: *selected_studyarea*). These names are mainly used to generate the output file names at the end of the pipeline.

## River Network {-}

After the data import of the river network data, the next step is the filtering of linestring geometries from the river network based on the attribute columns *dfdd* and *hyp* (target: *river_networks_non_dry_selected_streamtypes* in the file *preprocessing_targets.R*; Figure \@ref(fig:projectdirtree), line 30). *dfdd* classifies the geometries into BH140 (river), BH020 (canal) and BH030 (ditch). Canals and ditches are removed from the river network for several reasons through filtering out the geometries with the value BH140. Many of the canal and ditch geometries have missing stream order values, which is required for the following processing steps. Another reason is the assumption that canals might be hydraulically disconnected to the natural hydrologic system through walls with low permeability. Lastly, the overall importance of canals and ditches is low when comparing the number of geometries to rivers as shown in Figure \@ref(fig:dfddstatsbarplot). The column *hyp* classifies the geometries into the following degrees of hydrologic persistence: 1 (Perennial), 2 (Intermittent), 3 (Ephemeral) and 4 (Dry) [@gallaun_eu-hydro_2019]. Geometries with the value 4 (Dry) are removed. Then, missing and invalid stream order values are imputed with the value 1 to include them in the first hydrologic order (target: *river_networks_imputed_streamorder_canals_as_1*). The river network geometries are clipped to the study area by only keeping geometries that intersect with the study area (target: *db_river_networks_strahler_studyarea*). 

The next processing step implements a method to obtain linestring geometries that represent the mainstems of the rivers and its tributaries (target: *rivernetworks_merged_per_streamorder*). This is achieved by merging the geometries by a column containing an unique id for each mainstem. The mainstem is defined here as the longest path from the head water to the most distant river mouth (see geometries with the same *levelpath_id* in Figure \@ref(fig:mainstemscheme)B). As the underlying river network data has no column providing this information, it is necessary to first generate this id column by which we will conduct the merging of the lines (Belitz et al. (2019)[@belitz_multiorder_2019] made use of the already existing column *levelpathi* from their underlying NHDPlusV2 river network dataset). For doing so, it is now required to first derive a river network for each hydrologic order separately. This is achieved by keeping only geometries with a stream order equal or greater than the specific hydrologic order as described in [Background & Summary]. The river network of each hydrologic order is then sorted by the column *longpath* in descending order:

```{r, eval=FALSE}
river_network_path <- 
  river_network %>% 
  as_tibble() %>% 
  arrange(-longpath) %>% 
  select(object_id, nextdownid)
```

The column *longpath* indicates the length of the path from the start node of a linestring geometry to the end node of the most downstream geometry of the river network. Starting with the topmost geometry, all downstream geometries that constitute the longest path to the river mouth are identified by making use of the columns *object_id* and *nextdownid* and the R package *igraph*. This is the start of a loop over the sorted geometries. The column *object_id* provides an unique ID for every linestring geometry and *nextdownid* indicates the *object_id* of the next downstream geometry. Based on this information the function `subcomponent` of the *igraph* package identifies the *object_id*s of all geometries that belong to the longest path. These identified geometries are then removed from the river network for the next iteration of the loop. The subsequent iteration identifies all geometries downstream of the current topmost geometry of the remaining river network. This is repeated until the river network has no geometries left:

```{r, eval=FALSE}
longestpaths_list <- list()
i <- 1
while (nrow(river_network_path) > 0) {
  longestpaths_list[[i]] <-
    river_network_path %>%
    graph.data.frame(directed = TRUE) %>%
    subcomponent(1, mode = "out") %>%
    as.vector() %>%
    slice(river_network_path, .)

  river_network_path <-
    river_network_path %>%
    filter(!(object_id %in% longestpaths_list[[i]]$object_id))

  i <- i + 1
}
```

Subsequently, a column *levelpath_id* is added as a unique ID for all geometries belonging to the same mainstem (Figure \@ref(fig:mainstemscheme)B). The geometries of the respective river network is then merged based on this column (see difference in linestring geometries between Figure \@ref(fig:mainstemscheme)B and C). This results in a river network for each hydrologic order separately with a reduced number of geometries as multiple geometries are now summarised into mainstems.

The next step addresses the occurrence of flow splits in the river network (target: *river_networks_treated_brackets*). A flow split or divergence is defined here as junction of linestring geometries with more than one linestring geometry representing out-flowing streams (orange marks in Figure \@ref(fig:divergencescheme)). To transfer the methods from Belitz et al. (2019)[@belitz_multiorder_2019] for the calculation of EU-MOHP[@nolscher_eu-mohp_2021-1], it is required to remove minor flow paths that originate from such divergences from the river network for all hydrologic orders except for the first order. A classification of linestring geometries into major and minor flow paths is not directly provided by any column in the underlying river network dataset. Belitz et al. (2019)[@belitz_multiorder_2019] used the column *divergence* for removing all minor flow paths. In order to reproduce this removal of minor paths from all hydrologic orders greater than 1 without having this information, a more conservative approach is implemented. Therefore, all linestring geometries that intersect with the same other linestring geometry at their start and end node are removed from the river networks. Other minor paths that result from more complex divergences remained in the river network for further calculations (see *feature_id* in Figure \@ref(fig:divergencescheme)). 

Then, the river networks are sorted by the length of the linestring geometries in descending order and provided with an unique ID for each geometry in the column *feature_id* (target: *rivernetworks_feature_id*; see *feature_id* in Figure \@ref(fig:mainstemscheme)C).


## Surface Water Bodies {-}

Besides the import, there is only one other step in the targets pipeline that preprocesses the surface water bodies (target: *db_inland_waters_strahler* in the file *preprocessing_targets.R*; Figure \@ref(fig:projectdirtree), line 30). A filter is applied to only keep those geometries of surface water bodies that intersect with the river network. In order to assign a hydrologic order to the surface water bodies, the flow order of the river network geometries intersecting them is used, although the endowment of the surface water bodies with a flow order is not relevant for further processing, since the intersection is performed with the already generated hydrological orders. 


## Coastline {-}

The coastline geometries consist of a vast number of nodes which slows down many geometry operations and calculations. Therefore, many processing steps are parallelised across smaller batches of the coastline data which lead to many helper targets. First, the imported polygon geometries are unioned basin by basin (target: *coastline_unioned*). Contrary to the assumption based on the name "coastline", the geometry type of the coastline is polygons. Then, all geometries that don't intersect with the previously derived study area are removed (target: *coastline_filtered*). This is mainly to reduce the large number of geometries contained in the data caused by islands. A buffer of 3000 m is added to the remaining polygon geometries to compensate for inaccuracies of the match between the study area and the coastline contours. The value of 3000 m results from visual inspection of discrepancies between the coastline and the study area boundaries. This is relevant for the second next step. First, the buffered polygon geometries are unioned to a single multipolygon geometry in the PostGIS database for reducing the runtime of calculating the union operation (target: *coastline_buffer_unioned*). Now, the multipolygon geometry that represents the coastline is intersected with the study area as linestring geometry (target: *studyarea_as_coastline*). This intersection ensures that the shoreline lies exactly over the study area. Similarly, the next step determines the parts of the study area that are not coastline meaning where the contour of the coastline touches land instead of the ocean. This is achieved by calculating the difference of the study area and the same coastline geometry as before (target: *coastline_watershed*). All these targets can be found in the *studyarea_targets.R* file (Figure \@ref(fig:projectdirtree), line `r dirtree_lineno("studyarea_targets.R")`).


# EU-MOHP Calculation {-}

After preprocessing all required data layers as described previously, the next and last processing step comprises multiple smaller steps with the final goal to calculate and export the EU-MOHP[@nolscher_eu-mohp_2021-1] metrics. This core step is implemented in the target *db_objects_to_grass* which performs the calculation for the hydrologic orders separately in succession. Because the processing is analogous for all hydrologic orders, this step is described only once in general terms. This step also outsources all heavy raster based calculations to a GRASS GIS database. It starts with initiating a GRASS GIS database. Then, the linestring geometries of the river network are read from the PostGIS database. 
The linestring geometries of the coastline are provided with a column *feature_id* to uniquely identify each geometry. The counter of this *feature_id* starts after the highest *feature_id* of the river network to avoid duplicate values in this column when adding the coastline geometries to the river network in the following. The geometries from the river network and the coastline are merged to also include the coastline in the calculation of the Thiessen watersheds.
After combining these geometries, they are written into the GRASS GIS database where they are converted into the raster layer *river_network_raster* (rasterized) using the GRASS command `v.to.rast`:

```{r, eval=FALSE}
execGRASS(
  cmd = "v.to.rast",
  input = "river_network",
  output = "river_network_raster",
  type = "line",
  use = "attr",
  attribute_column = "feature_id",
  flags = c("overwrite", "d"),
  memory = GRASS_MAX_MEMORY
)
```

This results in a raster layer, where cell values represent the *feature_id* of the linestring geometries rasterized to raster features.
The GRASS command `r.neighbors` is used to ensure that mainstems of the river network in the raster layer are not interrupted by cells representing tributaries:

```{r, eval=FALSE}
execGRASS(
  cmd = "r.neighbors",
  input = "river_network_raster",
  selection = "river_network_raster",
  output = "river_network_raster",
  method = "minimum",
  flags = c("overwrite", "c")
)
```

This command replaces a cell value with the minimum value of its neighboring cells by setting the parameter *method* to *minimum*. As the *feature_id* is added as continuous counter starting at 1 after sorting the river network by the linestring geometry length in descending order, cell values are replaced in favor of the mainstems. 

Subsequently, the polygon geometries of the surface water bodies are imported into R from the PostGIS database, written into the GRASS GIS database, rasterized and added to the raster layer *river_network_raster* using the GRASS command `r.patch`.

All further calculations are performed separately for each of the 10 polygon geometries of the study area that has intersecting streams of the respective hydrologic order to avoid unnecessary calculations. After setting the region to the spatial extent of the respective study area polygon, the study area polygon is written into the GRASS GIS database. From this polygon, a raster mask is created to limit all further raster calculations to the study area.
Then, the distance from a raster grid cell center to the nearest stream (see DS in Eq. \@ref(eq:eqlp), \@ref(eq:eqdsd) and \@ref(eq:eqsd) or Figure \@ref(fig:schematicmohp)) is calculated using the GRASS command `r.grow.distance` with

```{r, eval=FALSE}
execGRASS(
  cmd = "r.grow.distance",
  input = "river_network_raster",
  distance = "river_network_distance_raster",
  value = "river_network_value_raster",
  flags = c("overwrite", "m")
)
```

This command creates the two raster layers *river_network_distance_raster* and *river_network_value_raster*. The former contains the horizontal distance to the nearest linestring geometry of the river network and the coastline, the latter represents the value of the *feature_id* of the nearest raster feature. The raster layer *river_network_value_raster* represents the Thiessen catchments. For deriving the Thiessen divides, this raster layer is converted into a vector layer of polygon geometries. The associated occurrence of dangling polygon outlines is reduced using the GRASS command *v.clean*. Subsequently, the rasterized outlines of these polygons are used as Thiessen divides. To calculate the distance the nearest Thiessen divide with the restriction to not cross a stream (see DD in Eq. \@ref(eq:eqlp), \@ref(eq:eqdsd) and \@ref(eq:eqsd) or Figure \@ref(fig:schematicmohp)), the GRASS command `r.walk` is used as follows:

```{r, eval=FALSE}
execGRASS(
  cmd = "r.walk",
  elevation = "river_network_distance_raster",
  friction = "friction",
  output = "thiessen_catchments_distance_raster",
  start_raster = "thiessen_catchments_lines_raster_thin",
  walk_coeff = "1,0,0,0",
  lambda = 1,
  memory = GRASS_MAX_MEMORY,
  flags = c("overwrite")
)
```

Through adjusting the parameters *walk_coeff* and *lambda*, this command calculates the horizontal distance between every cell and the nearest Thiessen divide in the raster layer *thiessen_catchments_lines_raster_thin* while being aware of the defined restriction. This restriction is taken into account by additionally providing the raster layer *friction* that represents friction costs. The *friction* raster layer is created by assigning a value of 1 billion to all non-empty cells of the *river_network_raster*. This value is greater then the maximum possible distance. Thus, for the calculation of the nearest divide by `r.walk` it is now ensured, that crossing a river is not an option leading to a preference of divides that lie on the same side of the stream as the respective cell. The resulting distances are stored in the raster layer *thiessen_catchments_distance_raster*. A discussion on the limitations of this implementation is provided in [Technical Validation]. 

Now, the EU-MOHP[@nolscher_eu-mohp_2021-1] measures are calculated using the GRASS command `r.mapcalc` and the two raster layers *river_network_distance_raster* and *thiessen_catchments_distance_raster* containing the cell values for DS and DD respectively. The EU-MOHP[@nolscher_eu-mohp_2021-1] measure DSD is calculated according to Eq. \@ref(eq:eqdsd) with

```{r, eval=FALSE}
execGRASS(
  cmd = "r.mapcalc",
  expression = glue::glue(
    "{FEATURE_NAMES[1]} = (river_network_distance_raster + thiessen_catchments_distance_raster)"
  ),
  flags = c("overwrite")
)
```
\noindent
where *`FEATURE_NAMES[1]`* is the raster layer name *`r FEATURE_NAMES[1]`* for DSD.
LP is calculated according to Eq. \@ref(eq:eqlp) with

```{r, eval=FALSE}
execGRASS(
  cmd = "r.mapcalc",
  expression = glue::glue(
    "{FEATURE_NAMES[2]} = round((river_network_distance_raster/{FEATURE_NAMES[1]})*10000)"
  ),
  flags = c("overwrite")
)
```
\noindent
where *`FEATURE_NAMES[2]`* is the raster layer name *`r FEATURE_NAMES[2]`* for LP. In order to be able to write the raster layer as integer data type with two decimals, the result of the division is multiplied by a factor of 10.000 and rounded. The data type integer reduces storage space compared with float. For the same reason, the previously calculated raster layer *`r FEATURE_NAMES[1]`* is rounded, too. 

As last measure, SD is calculated according to Eq. \@ref(eq:eqsd) with
```{r, eval=FALSE}
execGRASS(
  cmd = "r.mapcalc",
  expression = glue::glue(
    "{FEATURE_NAMES[3]} = round(river_network_distance_raster)"
  ),
  flags = c("overwrite")
)
```
\noindent
where *`FEATURE_NAMES[3]`* is the raster layer name *`r FEATURE_NAMES[3]`* for SD. Its calculation is simply performed by rounding the raster layer "river_network_distance_raster".

Lastly, the resulting raster layers for LP, DSD and SD are exported from the GRASS GIS database. Therefore, the directory *output_data* with the sub-directories `r FEATURE_NAMES %>% collapse_text_italic()` is created. The raster layers are written into these sub-directories in the GeoTIFF (*.tif*) file format.

# Data Descriptor {-}

To ensure reproducibility of the data descriptor itself, it is generated as part of the targets pipeline (target: *data_descriptor*). Also all tables and some figures are created from within the pipeline (see all targets in file *visualizations_data_descriptor_targets*). The data descriptor is written using the R package *rmarkdown* in the file *main.Rmd*. From there it is rendered as LaTeX (.tex) and PDF (.pdf) file format using the *knitr* package and exported to *data_descriptor/tex/* [@allaire_rmarkdown_2021, stodden_knitr_2014].

# Hardware {-}
The computations to generate the presented dataset were performed on a DELL PowerEdge C4140 Server with an Intel Xeon Gold 6240R CPU and 384 GB installed RAM. The installed operation system is Microsoft Windows Server 2019 Standard, version 10.0.17763 Build 17763. The total runtime of the pipeline as well as of individual targets is summarised in Table \@ref(tab:runtime).

```{r workflowfigure, echo=FALSE, out.width = "70%", fig.cap= "Workflow of the data processing in different software."}
include_graphics("data_descriptor/tex/workflow_figure.pdf")
```

```{r projectdirtree, crop=TRUE, echo=FALSE, out.width = "70%", fig.cap="Directory tree of the project directory; only relevant subdirectories and files are listed here."}
include_graphics("data_descriptor/tex/directory_tree.pdf")
```

```{r dfddstatsbarplot, echo=FALSE, out.width = "80%", fig.asp=0.5, fig.showtext = TRUE, fig.cap= 'Distribution of the values in the attribute column dfdd.'}
tar_read(dfdd_stats_bar_plot)
```

```{r mainstemscheme, echo=FALSE, out.width = "100%", fig.showtext = TRUE, fig.cap= knitr:::escape_latex("Schematic representation of the river network and its linestring geometries after import (A), after the identification of mainstems including the column levelpath_id (B) and after merging the linestring geometries by this column and adding a feature_id column (C).")}
include_graphics("data_descriptor/tex/mainstem_scheme.pdf")
```

```{r divergencescheme, echo=FALSE, out.width = "70%", fig.showtext = TRUE, fig.cap= knitr:::escape_latex('Schematic representation of the river network and its linestring geometries including divergences before (A) and after (B) the removal of minor paths under the condition that they intersect with the same linestring geometry at their start and end node. The linestring geometry with the feature_id = 8 has been removed from the river network in B, because it intersects the linestring geometry with feature_id = 1 at the start and end node. Whereas linestring geometry with feature_id = 7 remains in the river network, because it intersects with two different linestring geometries at its start and end node.')}
include_graphics("data_descriptor/tex/divergences_scheme.pdf")
```

```{r rivercanalconfusionplot, echo=FALSE, out.width = "80%", fig.showtext = TRUE, fig.cap= "Example of the river network data showing the confusion between the values BH140 (river), BH020 (canal) and BH030 (ditch) of the attribute column dfdd."}
tar_read(river_canal_confusion_plot)
```

```{r ddinaccuracies, echo=FALSE, out.width = "70%", fig.showtext = TRUE, fig.cap= 'Schematic example showing the source of inaccurate of DD in areas near headwaters caused by the applied method to calculate DD. The red distance as DD is incorrect, because it crosses the stream and therefore does not fulfill the defined condition. The correct DD would be the dark grey distance. The path to the correct side is equal to the correct DD (dark grey solid line) and therefore not drawn on the schematic map.'}
include_graphics("data_descriptor/tex/dd_inaccuracies.pdf")
```

```{r runtime, echo=FALSE}
table_data <- tar_read(targets_runtime_table)

table_data %>%
  kableExtra::kable("latex",
    booktabs = TRUE,
    # longtable = TRUE,
    linesep = "",
    caption = "Overview of the runtime and data size of all targets or processing steps in descending order."
  ) %>%
  kableExtra::kable_styling(full_width = TRUE) %>%
  kableExtra::column_spec(1, width = "20em") %>%
  kableExtra::add_header_above(c(" " = 1, "Runtime" = 4, "Data size" = 1)) %>%
  kableExtra::row_spec(nrow(table_data), bold = TRUE) %>%
  kableExtra::row_spec(nrow(table_data) - 1, hline_after = T)
```

\renewcommand{\arraystretch}{2}
```{r inputdata, echo=FALSE}
targets::tar_read(input_data_table) %>% 
  select(-'Data type') %>% 
  kableExtra::kable("latex",
        booktabs = TRUE,
        caption = "Overview of the required input data to reproduce this dataset.") %>% 
  kableExtra::kable_styling(full_width = TRUE) %>% 
  kableExtra::column_spec(1, width = "1em")
```
\renewcommand{\arraystretch}{1}

# References